# [Haskell] Grammer


åŸºæœ¬æ–‡æ³•
--------

ã‚¯ã‚»ãŒã‚ã‚‹ã‚‚ã®ã ã‘ã‚’è¨˜è¼‰ã—ã€ä»–è¨€èªã«ã‚ˆãã‚ã‚‹ã‚‚ã®ã¯çœç•¥ã—ã¾ã™ã€‚

### Not equal

`a /= b`

### é–¢æ•°

* å‰ç½®é–¢æ•°ã¨ä¸­ç½®é–¢æ•°ãŒã‚ã‚‹
* å‘¼ã³å‡ºã—ã¯å…¨ã¦ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Š

#### å‰ç½®é–¢æ•°

```
é–¢æ•°å å¼•æ•°1 å¼•æ•°2
```

ã»ã¨ã‚“ã©ã®ã‚±ãƒ¼ã‚¹ã¯å‰ç½®é–¢æ•°ã€‚

#### ä¸­ç½®é–¢æ•°

```
å¼•æ•°1 é–¢æ•°å å¼•æ•°2
```

é–¢æ•°åãŒç‰¹æ®Šæ–‡å­—ã ã‘ã‹ã‚‰ãªã‚‹å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ä¸­ç½®é–¢æ•°ã¨ãªã‚‹ã€‚

```
> a !!! b = a*b
> 10 !!! 2
20
```

### å‰ç½®é–¢æ•°ã¨ä¸­ç½®æ›æ•°ã®å¤‰æ›

å‰ç½®é–¢æ•°ã‚’ãƒãƒƒã‚¯ã‚¯ã‚©ãƒ¼ãƒˆã§æ‹¬ã‚‹ã¨ä¸­ç½®æ›æ•°ã«ãªã‚‹ã€‚

```
> max 16 5
16
> 16 `max` 5
16
```

â„¹ï¸ é–¢æ•°å®šç¾©ã®æ™‚ã‚‚ä½¿ãˆã‚‹


ä¸­ç½®é–¢æ•°ã‚’`()`ã§æ‹¬ã‚‹ã¨å‰ç½®é–¢æ•°ã«ãªã‚‹ã€‚

```
> 5 == 3
False
> (==) 5 3
False
```


### å‘½å

* camelCase
  * PascalCaseã«ã¯ãã‚‚ãã‚‚ã§ããªã„ (â“)
* ã‚¢ãƒã‚¹ãƒˆãƒ­ãƒ•ã‚£`'`ãŒä»˜ãå ´åˆã€ãã®é–¢æ•°ã¯ **æ­£æ ¼** ã§ã‚ã‚‹ã“ã¨ãŒå¤šã„

### ä¸‰é …æ¼”ç®—å­

` = if ... then ... else ...`

elseã¯å¿…é ˆ


å‘½åè¦ç´„
--------

### å¤‰æ•°

camelCase

* ä½¿ã‚ãªã„å¤‰æ•°ã¯`_`

### å‹

PascalCase

### å‹å¤‰æ•°

camelCase.. ãŸã åŸºæœ¬çš„ã«1æ–‡å­—

### é–¢æ•°

camelCase


ã‚¨ãƒ©ãƒ¼
------

`error <ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸>`ã§ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹ã€‚

```
> error "hogehoge"
*** Exception: hogehoge
```


ãƒªã‚¹ãƒˆ
------

`[1, 2, 3]`

### é€£çµ

`[1, 2] ++ [3, 4]`

å·¦å´ã®ãƒªã‚¹ãƒˆã¯æœ€å¾Œã¾ã§èµ°æŸ»ã•ã‚Œã¦ã—ã¾ã†ã®ã§ã€çµåˆã¯ **consæ¼”ç®—å­** ã‚’ä½¿ã£ãŸæ–¹ãŒã‚ˆã„ã€‚

`1:2:[3, 4]`

ãªãŠã€`[3, 4]`ã¯`3:4:[]`ã®ç³–è¡£æ§‹æ–‡ã€‚


### ã‚¢ã‚¯ã‚»ã‚¹

`[1, 2, 3] !! 1`


### æ¯”è¼ƒ

`==`, `>`, `<` ãªã©ãŒä½¿ãˆã‚‹ã€‚

### ãƒ¬ãƒ³ã‚¸

ç¯„å›²æŒ‡å®šã®ç°¡ç•¥è¡¨è¨˜ãŒã§ãã‚‹ã€‚

* `[1,2,3,4,5]`ã¯`[1..5]`
* `[1,3,5,7,9]`ã¯`[1,3..9]`
* è¦ç´ 1ã®ç„¡é™ãƒªã‚¹ãƒˆã¯`[1,1..]`
* `abcdfeghijklmnopqrstuvwxyz`ã¯`['a','b'..'z']`
* `[5,4,3,2,1]`ã¯`[5,4..1]` (`[5..1]`ã¯ãƒ€ãƒ¡)

ä¸Šé™æ•°ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯å¾Œè¿°ã®`take`ã‚’ä½¿ã†ã€‚  
ç„¡é™ãƒªã‚¹ãƒˆã¯é…å»¶è©•ä¾¡ãªã®ã§Haskellã£ã½ã„ã€‚

âš ï¸æµ®å‹•å°æ•°ç‚¹ã¯ç²¾åº¦ã®å•é¡Œã§ã†ã¾ãã„ã‹ãªã„ã¨ããŒã‚ã‚‹


### åŸºæœ¬çš„ãªãƒªã‚¹ãƒˆé–¢æ•°

|   é–¢æ•°    |              æ„å‘³              |        è¨˜è¼‰ä¾‹        |    çµæœ     |
| --------- | ------------------------------ | -------------------- | ----------- |
| head      | å…ˆé ­ã®è¦ç´ ã‚’å–å¾—               | head [1..5]          | 1           |
| take      | å…ˆé ­ã‹ã‚‰æŒ‡å®šæ•°ã®è¦ç´ ã‚’å–å¾—     | take 3 [1..]         | [1,2,3]     |
| init      | æœ«å°¾ã®è¦ç´ ä»¥å¤–ã‚’å–å¾—           | init [1..5]          | [1,2,3,4]   |
| tail      | å…ˆé ­ã®è¦ç´ ä»¥å¤–ã‚’å–å¾—           | tail [1..5]          | [2,3,4,5]   |
| drop      | å…ˆé ­ã‹ã‚‰æŒ‡å®šæ•°ã®è¦ç´ ä»¥å¤–ã‚’å–å¾— | drop 3 [1..5]        | [4,5]       |
| last      | æœ«å°¾ã®è¦ç´ ã‚’å–å¾—               | last [1..5]          | 5           |
| length    | é•·ã•ã‚’å–å¾—                     | length [1..5]        | 5           |
| null      | ç©ºã§ã‚ã‚‹ã‹åˆ¤å®š                 | null []              | True        |
| reverse   | é€†é †ã‚’å–å¾—                     | reverse [1..5]       | [5,4,3,2,1] |
| maximum   | æœ€å¤§å€¤ã‚’å–å¾—                   | maximum [1..5]       | 5           |
| minimum   | æœ€å°å€¤ã‚’å–å¾—                   | minimum [1..5]       | 1           |
| sum       | å…¨ã¦ã®å’Œã‚’å–å¾—                 | sum [1..5]           | 15          |
| product   | å…¨ã¦ã®ç©ã‚’å–å¾—                 | product [1..5]       | 120         |
| elem      | è¦ç´ ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹     | elem 3 [1..5]        | True        |
| cycle     | ãƒªã‚¹ãƒˆã‚’ç„¡é™ã«ç¹°ã‚Šè¿”ã™         | take 5 $ cycle [1,2] | [1,2,1,2,1] |
| repeat    | è¦ç´ ã‚’ç„¡é™ã«ç¹°ã‚Šè¿”ã™           | take 5 $ repeat 2    | [2,2,2,2,2] |
| replicate | è¦ç´ ã‚’è¤‡è£½ã™ã‚‹                 | replicate 3 5        | [5,5,5]     |

`elem`ã¯ä¸­ç½®ã§ä½¿ã‚ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã€‚


### å†…åŒ…è¡¨è¨˜

```haskell
> [x*10 | x <- [1..5], x /= 1, x /= 4]
[20,30,50]

> [x*y | x <- [1..5], y <- [1,10,100]]
[1,10,100,2,20,200,3,30,300,4,40,400,5,50,500]
```

`x <- [1..5]`ã®ã‚ˆã†ãªéƒ¨åˆ†ã‚’**ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿**ã¨å‘¼ã¶ã€‚


ã‚¿ãƒ—ãƒ«
------

`(1, 1.1, 'a')`

* è¤‡æ•°ã®é•ã†å‹ã®è¦ç´ ã‚’1ã¤ã®å€¤ã¨ã—ã¦æ‰±ã† (ãƒ˜ãƒ†ãƒ­ã§ã‚ã‚‹)
* ã‚µã‚¤ã‚ºãŒå›ºå®š

### å–ã‚Šå‡ºã—

ãƒšã‚¢(è¦ç´ ãŒ2ã¤)ã®ã‚¿ãƒ—ãƒ«ã«ã¯ä»¥ä¸‹ãŒã‚ã‚‹ã€‚

* `fst` ã§1ã¤ç›®ã®è¦ç´ å–ã‚Šå‡ºã—
* `snd` ã§2ã¤ç›®ã®è¦ç´ å–ã‚Šå‡ºã—

### 2ã¤ã®ãƒªã‚¹ãƒˆã‹ã‚‰ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã‚’ä½œã‚‹

`zip`ã‚’ä½¿ã†ã€‚

```haskell
> zip [1..5] ['a'..'e']
[(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e')]
```

ãƒªã‚¹ãƒˆã®é•·ã•ãŒé•ã†å ´åˆã¯çŸ­ã„æ–¹ã«ã‚ã‚ã›ã‚‹ã€‚  
ç„¡é™ãƒªã‚¹ãƒˆã¨zipã™ã‚‹ã¨ï½¶ï½¯ï½ºï½²ï½²

### ç©ºã‚¿ãƒ—ãƒ«

`()`ã¯ç©ºã‚¿ãƒ—ãƒ«ã€‚Unitã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ã€‚


å‹
--

### å‹å®£è¨€

`é–¢æ•°å :: å¼•æ•°ã®å‹ -> æˆ»ã‚Šå€¤ã®å‹`

è¤‡æ•°å¼•æ•°ãŒã‚ã‚‹å ´åˆã¯`->`ã§ç¹‹ã

`é–¢æ•°å :: å¼•æ•°1ã®å‹ -> å¼•æ•°2ã®å‹ -> å¼•æ•°3ã®å‹ -> æˆ»ã‚Šå€¤ã®å‹`


### ä¸€èˆ¬çš„ãªå‹

|  å‹å   |        æ„å‘³        |          å‚™è€ƒ          |
| ------- | ------------------ | ---------------------- |
| Int     | æœ‰ç•Œãªæ•´æ•°         |                        |
| Integer | æœ‰ç•Œã§ã¯ãªã„æ•´æ•°   | åŠ¹ç‡çš„ã§ã¯ãªã„         |
| Float   | æµ®å‹•å°æ•°ç‚¹æ•°       | å°æ•°ç‚¹ä»¥ä¸‹ç¬¬7æ¡ã¾ã§    |
| Double  | å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•° | å°æ•°ç‚¹ä»¥ä¸‹ç¬¬15æ¡ã¾ã§   |
| Bool    | çœŸç†å€¤å‹           | True or False          |
| Char    | Unicodeæ–‡å­—        | ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§æ‹¬ã‚‹ |


### å‹å¤‰æ•°

* ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®ã‚ˆã†ãªã‚‚ã®
* å°æ–‡å­—ã‹ã‚‰å§‹ã¾ã‚‹
* æ…£ä¾‹çš„ã«ä¸€æ–‡å­—ã§ã‚ã‚‹ã“ã¨ãŒå¤šã„ (a, bãªã©)

headã®å ´åˆ

```haskell
> :t head
head :: [a] -> a
```

å‹å¤‰æ•°ã‚’ç”¨ã„ãŸé–¢æ•°ã‚’**å¤šç›¸çš„é–¢æ•°**ã¨å‘¼ã¶ã€‚


### å‹ã‚¯ãƒ©ã‚¹

* æŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹
* å‹ã¯ã‚ã‚‹å‹ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚Šå¾—ã‚‹
* ã‚ã‚‹å‹ã‚¯ãƒ©ã‚¹ã«å±ã™ã‚‹é–¢æ•° = **ãã®å‹ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰**

`==`ã®å…·ä½“ä¾‹

```haskell
> :t (==)
(==) :: Eq a => a -> a -> Bool
```

* å‹ã‚¯ãƒ©ã‚¹`Eq`ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ãªã‚‹å‹`a`ã®å¤‰æ•°ã‚’2ã¤å—ã‘å–ã‚Šã€`Bool`ã‚’è¿”ã™ ã¨ã„ã†ã“ã¨
* `=>`ã®å‰ã«ã‚ã‚‹ã‚‚ã®ã¯**å‹ã‚¯ãƒ©ã‚¹åˆ¶ç´„**
* å‹ã‚¯ãƒ©ã‚¹åˆ¶ç´„ãŒè¤‡æ•°ã®å ´åˆã¯ `(Eq a, Num b) => a -> b)` ã®ã‚ˆã†ã«æ›¸ã

âš ï¸å‹ã‚¯ãƒ©ã‚¹ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã®ã‚¯ãƒ©ã‚¹ã¨ã¯å…¨ãé–¢ä¿‚ãªã„


#### Eqå‹ã‚¯ãƒ©ã‚¹

| å®Ÿè£…ã™ã¹ãé–¢æ•° |       å‹       |     èª¬æ˜     |
| -------------- | -------------- | ------------ |
| ==             | a -> a -> Bool | ç­‰ã—ã„ã‹     |
| /=             | a -> a -> Bool | ç­‰ã—ããªã„ã‹ |


#### Ordå‹ã‚¯ãƒ©ã‚¹

é †åºã¥ã‘

| å®Ÿè£…ã™ã¹ãé–¢æ•° |         å‹         |                    èª¬æ˜                     |
| -------------- | ------------------ | ------------------------------------------- |
| compare        | a -> a -> Ordering | 2å€¤ã® å¤§ãã„(GT)/å°ã•ã„(LT)/ç­‰ã—ã„(EQ) åˆ¤å®š |


#### Showå‹ã‚¯ãƒ©ã‚¹

æ–‡å­—åˆ—ã¨ã—ã¦ã®è¡¨ç¾

| å®Ÿè£…ã™ã¹ãé–¢æ•° |     å‹      | èª¬æ˜ |
| -------------- | ----------- | ---- |
| show           | a -> String |      |


#### Readå‹ã‚¯ãƒ©ã‚¹

æ–‡å­—åˆ—ã‚’å—ã‘å–ã‚Šã€Readã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‹ã®å€¤ã‚’è¿”ã™ã€‚

| å®Ÿè£…ã™ã¹ãé–¢æ•° |     å‹      | èª¬æ˜ |
| -------------- | ----------- | ---- |
| read           | String -> a |      |

âš ï¸å‹æ³¨é‡ˆã‚’ä½¿ã£ã¦æ˜ç¤ºçš„ã«`a`ãŒä½•å‹ã§ã‚ã‚‹ã‹.. æŒ‡å®šã—ãªã‘ã‚Œã°ã„ã‘ãªã„ã‚±ãƒ¼ã‚¹ã‚‚ã‚ã‚‹


#### Enumå‹ã‚¯ãƒ©ã‚¹

é †å ´ã«ä¸¦ã‚“ã åˆ—æŒ™ã§ãã‚‹å‹

| å®Ÿè£…ã™ã¹ãé–¢æ•° |   å‹   |      èª¬æ˜      |
| -------------- | ------ | -------------- |
| succ           | a -> a | é€£ç¶šã™ã‚‹æ¬¡ã®å€¤ |
| pred           | a -> a | é€£ç¶šã™ã‚‹å‰ã®å€¤ |

Char, Int, ãªã©


#### Boundedå‹ã‚¯ãƒ©ã‚¹

ä¸Šé™ã¨ä¸‹é™ã‚’æŒã¤

| å®Ÿè£…ã™ã¹ãé–¢æ•° | å‹  |  èª¬æ˜  |
| -------------- | --- | ------ |
| minBound       | a   | æœ€å°å€¤ |
| maxBound       | a   | æœ€å¤§å€¤ |

â“ å¤šç›¸å®šæ•°

#### Numå‹ã‚¯ãƒ©ã‚¹

å®Ÿæ•°å…¨ã¦

#### Floatingå‹ã‚¯ãƒ©ã‚¹

æµ®å‹•å°æ•°ç‚¹

#### Integralå‹ã‚¯ãƒ©ã‚¹

æ•´æ•°ã®ã¿

### å‹æ³¨é‡ˆ

`... :: å‹`

å‹ã‚’æ•™ãˆã¦ã‚ã’ã‚‹ã€‚

```
> read "5"
*** Exception: Prelude.read: no parse
> read "5" :: Int
5
```


ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ
--------------

å…¨ä½“ã¨ã—ã¦ã¯åˆ†å‰²ä»£å…¥ã«è¿‘ã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚

ä¸Šã‹ã‚‰é †ç•ªã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦ã—ã€ä¸€è‡´ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã€‚

```haskell
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

### ã‚¿ãƒ—ãƒ«ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

`OK`
```haskell
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors a b = (fst a + fst b, snd a + snd b)
```

`GOOD`
```haskell
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
```

### ãƒªã‚¹ãƒˆã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

secondãŒ3ã®ã‚¿ãƒ—ãƒ«ã«å¯¾ã—ã¦ã®ã¿filterã—ã€fstã«100ã‚’ã‹ã‘ãŸå€¤ã«å¤‰æ›ã™ã‚‹ã€‚  
é–¢æ•°å‹ã®å ´åˆã€filterã¨mapãŒã„ã‚‹å‡¦ç†ã€‚

```haskell
> xs = [(1,3),(4,3),(2,4),(5,3),(5,6),(3,1)]
> [a*100 | (a, 3) <- xs]
[100,400,500]
```

headã®å†å®Ÿè£…hd

```haskell
hd :: [a] -> a
hd [] = error "Invalid"
hd (x:_) = x
```

è¤‡æ•°å¤‰æ•°ã«æŸç¸›ã™ã‚‹å ´åˆã¯ä¸¸ã‚«ãƒƒã‚³ã§å›²ã¾ãªã„ã¨ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚  
ã¤ã¾ã‚Šã€ `hd x:_ = x` ã ã¨ãƒ€ãƒ¡ã€‚

* `x:_ = [1,2,3]`ã®ã‚ˆã†ãªä»£å…¥ã¯ã§ãã‚‹
* `(x:[])`ã‚„`(x:y:[])`ã¯`[x]`ã‚„`[x,y]`ã¨ã‚‚æ›¸ã‘ã‚‹
  * ãŸã ã—ã€`(x:_)`ã‚„`(x:y:_)`ã¯è§’ã‚«ãƒƒã‚³ã§è¡¨ç¾ã§ããªã„
* `++`ã¯ä½¿ãˆãªã„

### asãƒ‘ã‚¿ãƒ¼ãƒ³

`all@(x:xs)`ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€`all = (x:xs)`ã¨ã¿ãªã—ã¦æ‰±ãˆã‚‹ã€‚

```haskell
> duplicateHead :: [a] -> [a]
> duplicateHead all@(x:xs) = x:all
> duplicateHead [3,2,4]
[3,3,2,4]
```

### caseå¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ

ä¸Šã§ç™»å ´ã—ãŸã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ..

```haskell
hd :: [a] -> a
hd [] = error "Invalid"
hd (x:_) = x
```

caseã‚’ä½¿ã†ã¨ã“ã†ãªã‚‹

```haskell
hd :: [a] -> a
hd xs = case xs of [] -> error "Invalid"
                (x:_) -> x
```

ä¸Šã§ç™»å ´ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¨ã®é•ã„ã¯ã€é–¢æ•°å®šç¾©ã®ã¨ãä»¥å¤–ã‚‚ä½¿ãˆã‚‹ã“ã¨ã€‚  
ä¸‰é …æ¼”ç®—å­ã¿ãŸã„ãªãƒãƒªã§å¼ã®é€”ä¸­ã«å‡ºç¾å¯èƒ½ã€‚

```haskell
len :: [a] -> String
len xs = "Length is" ++ case xs of
  [] -> "empty"
  [x] -> "only"
  xs -> "many"
```


ã‚¬ãƒ¼ãƒ‰
------

* ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§çµã‚Šè¾¼ã¾ã‚ŒãŸå¾Œã®å¼•æ•°ãƒã‚§ãƒƒã‚¯
* ãƒ‘ã‚¤ãƒ—æ–‡å­—ã§ç¹‹ãã€å·¦è¾º:çœŸç†å€¤å¼ & å³è¾º:çµæœ ã‚’æ›¸ã
  * ãƒ‘ã‚¤ãƒ— = caseã®ãƒãƒª
* ä¸»ã«ç¯„å›²ã‚’ç¤ºã™å ´åˆã€‚å€¤ã®ä¸€è‡´ãªã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ã‚‚å¯èƒ½

```haskell
humanKind :: Int -> String
humanKind age
  | age < 35 = "è‹¥è€…"
  | age < 65 = "ãŠã£ã•ã‚“"
  | otherwise = "ã˜ã£ã¡ã‚ƒã‚“"
```

`otherwise`ãŒç„¡ã‘ã‚Œã°æ¬¡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³(â‰ ã‚¬ãƒ¼ãƒ‰)ã«ç§»ã‚‹ã€‚


where
-----

èª¬æ˜å¤‰æ•°ä»£å…¥ã®ã‚ˆã†ãªã‚‚ã®ã€‚

```haskell
bmiTell :: Double -> Double -> String
bmiTell weight height
  | bmi < 15.0 = "too low"
  | bmi < 22.5 = "ok"
  | otherwise = "too high"
  where bmi = weight / height^2
```

è¨ˆç®—é‡ã‚‚æ¸›ã‚‹ã—å¯èª­æ€§ã‚‚ä¸ŠãŒã‚‹ã®ã§è¨ˆç®—ãŒé‡è¤‡ã™ã‚‹å ´åˆã¯ä½¿ãŠã†ã€‚

whereã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯åŒä¸€ãƒ‘ã‚¿ãƒ¼ãƒ³å†…ã€‚åˆ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯è§£æ±ºã—ãªã„ã€‚


let
---

whereã¨ä¼¼ã¦ã„ã‚‹ãŒæœ€åˆã«æŸç¸›ã™ã‚‹ã€‚

```haskell
sum3 :: Num a => a -> a -> a -> a
sum3 a b c =
  let ab = a + b
  in ab + c
```

ğŸ˜„whereã¨é•ã„letã¯å¼ã§ã‚ã‚‹ã‹ã‚‰ä»¥ä¸‹ã®ã‚ˆã†ãªè¡¨ç¾ã‚‚å¯èƒ½ã€‚

```haskell
> 1 + (let a = 2; b = 3 in a*b)
7
```

ğŸ˜¢whereã¨é•ã„letã¯ã‚¬ãƒ¼ãƒ‰ã¨ä½µç”¨ã§ããªã„(ã‚¬ãƒ¼ãƒ‰ã®ä¸­ã¾ã§æŸç¸›ã§ããªã„)  
ã‚¬ãƒ¼ãƒ‰ã—ãŸã‘ã‚Œã°letã‚’ä½¿ã†ã“ã¨ã€‚å†…åŒ…è¡¨è¨˜ã§æ¡ä»¶æŒ‡å®šã™ã‚‹ã¨ãã«ä¾¿åˆ©ã€‚

```haskell
calcBmis :: [(Double, Double)] -> [Double]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h^2, bmi > 25.0]
```


ã‚«ãƒªãƒ¼åŒ–
--------

* `ã‚«ãƒªãƒ¼åŒ–é–¢æ•°`: 1å¼•æ•°ã§ã‚ã‚Šã€æ¬¡ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹é–¢æ•°ã‚’è¿”ã™é–¢æ•°
* `éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸé–¢æ•°`: é–¢æ•°ã‚’æœ¬æ¥ã‚ˆã‚Šå°‘ãªã„å¼•æ•°ã§å‘¼ã³å‡ºã—ãŸã¨ãã«å¾—ã‚‰ã‚Œã‚‹é–¢æ•°

`max4 = max 4`ã®å ´åˆ

* `max`ã¯ã‚«ãƒªãƒ¼åŒ–é–¢æ•°
* `max4`ã¯éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸé–¢æ•°

â“Haskellã®é–¢æ•°ã¯å…¨ã¦ã‚«ãƒªãƒ¼åŒ–é–¢æ•°ã§ã‚‚ã‚ã‚‹

### ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã‚‹ä¸­ç½®æ›æ•°ã®éƒ¨åˆ†é©ç”¨

ä¸­ç½®æ›æ•°`+`ã‚’éƒ¨åˆ†é©ç”¨ã™ã‚‹å ´åˆã¯`(/10)` or `(10/)`ã®ã‚ˆã†ã«ã‚«ãƒƒã‚³ã§æ‹¬ã£ã¦ç‰‡å´ã ã‘å€¤ã‚’åŸ‹ã‚ã‚‹ã€‚  
ã“ã‚Œã‚’ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã„ã†ã€‚

```haskell
> f1 = (/10)
> f2 = (10/)
> f1 100
10.0
> f2 100
0.1
```

âš ï¸`-`ã ã‘ã¯æ³¨æ„ã€‚`(-4)`ã¯ãŸã ã®ãƒã‚¤ãƒŠã‚¹4ã§ã‚ã‚‹ã‹ã‚‰`(subtract 4)`ã¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

`zipWith`ã¯ä¾¿åˆ©ã€‚

```haskell
> :t zipWith
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
> zipWith (*) [1..5] $ cycle [1,-1]
[1,-2,3,-4,5]
```

### é«˜éšé–¢æ•°ã‚’ä½¿ã£ãŸä¾¿åˆ©ãªæ¨™æº–é–¢æ•°ä¸€è¦§

|   é–¢æ•°    |                  æ„å‘³                  |            è¨˜è¼‰ä¾‹            |    çµæœ    |
| --------- | -------------------------------------- | ---------------------------- | ---------- |
| zipWith   | 2ã¤ã®é…åˆ—ã‚’æ¼”ç®—ã—ãŸçµæœã®é…åˆ—ã‚’ä½œã‚‹    | zipWith (+) [1,2,3] [4,5,6]  | [5,7,9]    |
| flip      | æœ€åˆã®2å¼•æ•°ãŒå…¥ã‚Œæ›¿ã‚ã£ãŸé–¢æ•°ã‚’ä½œã‚‹    | flip compare 10 5            | LT         |
| map       | å‡¦ç†ã‚’åŠ ãˆãŸé…åˆ—ã‚’ä½œã‚‹                 | map (+3) [10,11,12]          | [13,14,15] |
| filter    | æ¡ä»¶ã‚’æº€ãŸã™è¦ç´ ã®ã¿ã®é…åˆ—ã‚’ä½œã‚‹       | filter even [10..15]         | [10,12,14] |
| takeWhile | é€£ç¶šã—ã¦æ¡ä»¶ãŒæº€ãŸã™ç®‡æ‰€ã¾ã§é…åˆ—ã‚’ä½œã‚‹ | takeWhile even [2,4,7,6,8,9] | [2, 4]     |


ãƒ©ãƒ ãƒ€å¼
--------

`(\x -> x + 1)`

* `Î»`ã«ä¼¼ãŸ`\`ã‚’é ­ã«ã¤ã‘ã¦è¡¨ç¾
* æ™®é€šã¯å…¨ä½“ã‚’ã‚«ãƒƒã‚³ã§æ‹¬ã‚‹
* è¤‡æ•°å¼•æ•°ã¯ `(\x y -> x + y)`

3ã®å€æ•°

```haskell
> filter (\x -> x `mod` 3 == 0) [1..10]
[3,6,9]
```


ç•³ã¿è¾¼ã¿
--------

accumuratorã¯ç•³ã¿è¾¼ã¿ã«ã‚ˆã‚‹é€”ä¸­çµæœ

### å·¦ç•³ã¿è¾¼ã¿ foldl

å·¦ã‹ã‚‰ç•³ã¿è¾¼ã‚€ã€‚

```haskell
> foldl (-) 0 [1..5]
-15
```

* `((((0 - 1) - 2 ) - 3) - 4) - 5`
  * ã¤ã¾ã‚Š `0 - 1 - 2 - 3 - 4 - 5` ã¨ç­‰ä¾¡
* `foldl`ã®ç¬¬ä¸€å¼•æ•°é–¢æ•°ã®å¼•æ•°ã¯ `accumurator, x`ã®é †

### å³ç•³ã¿è¾¼ã¿ foldr

å³ã‹ã‚‰ç•³ã¿è¾¼ã‚€ã€‚

```haskell
> foldr (-) 0 [1..5]
3
```

* `5 - (4 - (3 - (2 - (1 - 0))))` ã¨ç­‰ä¾¡
* `foldr`ã®ç¬¬ä¸€å¼•æ•°é–¢æ•°ã®å¼•æ•°ã¯ `x, accumurator`ã®é †
  * **`foldl`ã¨é€†ãªã®ã§æ³¨æ„**
* **å³ç•³ã¿è¾¼ã¿ã¯ç„¡é™ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦å‹•ä½œã™ã‚‹** ã¨ã„ã†ã®ãŒæœ€å¤§ã®å¼·ã¿ï¼
  * filterãªã©ãƒªã‚¹ãƒˆå†ç”Ÿæˆç³»ã§ã¯ã¾ãšè€ƒãˆã‚‹

### åˆæœŸå€¤çœç•¥ã® foldl1 foldr1

âš ï¸ãƒªã‚¹ãƒˆãŒç©ºã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã®ã§æ³¨æ„ã€‚ãƒªã‚¹ãƒˆãŒç©ºã§ãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ä½¿ã†ã“ã¨

```haskell
> foldl1 (-) [1..5]
-13
```

* `1 - 2 - 3 - 4 - 5`ã¨ç­‰ä¾¡

```haskell
> foldr1 (-) [1..5]
3
```

* `5 - (4 - (3 - (2 - 1)))` ã¨ç­‰ä¾¡
* åˆæœŸå€¤ã¯å³ç«¯ã®`5`ã§ã¯ãªãã€å·¦ç«¯ã®`1`

### æ­£æ ¼ãªç•³ã¿è¾¼ã¿

ç•³ã¿è¾¼ã¿ã¯é…å»¶è©•ä¾¡ã§ã‚ã‚‹ãŒã‚†ãˆã«å®Œäº†ã™ã‚‹ã¾ã§é€”ä¸­çµŒéã‚’ãƒ¡ãƒ¢ãƒªã«å±•é–‹ã™ã‚‹ã€‚  
ãã®ãŸã‚ã€å¯¾è±¡ã®ãƒªã‚¹ãƒˆãŒå·¨å¤§ã ã¨Stack Overflowã«ãªã‚‹ã€‚

```haskell
foldl (+) 0 (replicate 100000000 1)
```

`foldl`ã®ä»£ã‚ã‚Šã«`Data.List`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®`foldl'`ã‚’ä½¿ã†ã¨æ­£æ ¼ã§å³æ™‚è©•ä¾¡ã§ãã‚‹ã€‚

```haskell
import Data.List (foldl')
foldl' (+) 0 (replicate 100000000 1)
```

ãªãŠ`foldr'`ã¯å­˜åœ¨ã—ãªã„ã€‚

### scan

`fold`ã¯æœ€çµ‚çµæœã®ã¿ã ãŒã€`scan`ã¯é€”ä¸­çµŒéã‚’å«ã‚ãŸãƒªã‚¹ãƒˆã‚’è¿”å´ã™ã‚‹ã€‚  
`scanl`, `scanr`, `scanl1`, `scanr1`ãªã©ä¸€é€šã‚Šã‚ã‚‹ã€‚

```haskell
> scanl1 (+) [1..10]
[1,3,6,10,15,21,28,36,45,55]
> scanr1 (+) [1..10]
[55,54,52,49,45,40,34,27,19,10]
```

`scanl`ã¨`scanr`ã§ã¯é †åºãŒé€†ã«ãªã‚‹ã®ã§æ³¨æ„ã€‚


é–¢æ•°é©ç”¨æ¼”ç®—å­
--------------

`$`ã®ã“ã¨ã€‚  
ä»¥ä¸‹ã¯åŒã˜æ„å‘³ã€‚

```haskell
> sum (filter even [1..10])
30
> sum $ filter even [1..10]
30
```

`(...)`ãŒ`$ ...`ã«ãªã‚‹ã¨è¦šãˆã‚‹æ–¹ãŒç°¡å˜ã‹ã‚‚ã€‚  
é€šå¸¸ã¯å·¦çµåˆã ã‘ã©ã€`$`ãŒç™»å ´ã—ãŸç¬é–“ã€ãŠã„ã¡ã‚‡ã£ã¨ã¾ã¦ã‚ˆã€ã¨ãªã‚‹ã‚“ã§ã™ãªğŸ˜˜


é–¢æ•°åˆæˆ
--------

`.`ã®ã“ã¨ã€‚  
ä»¥ä¸‹ã¯åŒã˜æ„å‘³ã€‚

```haskell
> sum $ map (*10) $ filter even [1..10]
300
> sum . map (*10) $ filter even [1..10]
300
```

é–¢æ•°ã¯åˆæˆã®çµæœã¯é–¢æ•°ãªã®ã§ã€é–¢æ•°é©ç”¨æ¼”ç®—å­ã¨ã¯ç•°ãªã‚Š`=`ãŒä½¿ãˆã‚‹ã€‚

```haskell
> method = sum . map (*10) . filter even
> method [1..10]
300
```


ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«
----------------------

```haskell
summ xs = foldl1 (+) xs
```

ã“ã®é–¢æ•°ã¯`xs`ã‚’ä¸¡è¾ºã‹ã‚‰å‰Šé™¤ã—ã¦ã‚‚æˆç«‹ã™ã‚‹ã€‚  
ãªãœãªã‚‰`summ`ã¯`foldl1`ã‚’éƒ¨åˆ†é©ç”¨ã—ãŸé–¢æ•°ã«ãªã‚‹ã‹ã‚‰ã€‚

```haskell
summ = foldl1 (+)
```

ã“ã®ã‚ˆã†ãªçœç•¥ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒ³ãƒˆãƒ•ãƒªãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«ã¨ã„ã†ã€‚


ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
----------

é–¢æ•°ã€å‹ã€å‹ã‚¯ãƒ©ã‚¹ãªã©ãŒå®šç¾©ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ã“ã¨ã€‚

Preludeã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã€‚

### ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã«æ›¸ã‹ãªã‘ã‚Œã°ã„ã‘ãªã„ã€‚

`import ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å`ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã€‚

```haskell
*Main Lib> import Data.List
*Main Lib Data.List> :t nub
nub :: Eq a => [a] -> [a]
```

ä¸€éƒ¨ã®ã¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯æŒ‡å®šã™ã‚‹ã€‚

```haskell
> import Data.List (nub, sort)
```

åˆ¥åã‚¤ãƒ³ãƒãƒ¼ãƒˆ

```haskell
> import qualified Data.Map as M
```

âš ï¸ `Data.Map`ãŒèª­ã¿è¾¼ã‚ãªã„..


### Data.List

|    é–¢æ•°    |             æ„å‘³             |               è¨˜è¼‰ä¾‹                |           çµæœ            |
| ---------- | ---------------------------- | ----------------------------------- | ------------------------- |
| nub        | é‡è¤‡ã™ã‚‹å€¤ã‚’ãƒ¦ãƒ‹ãƒ¼ã‚¯ã«ã™ã‚‹   | nub [1,2,3,2,1,3]                   | [1,2,3]                   |
| words      | æ–‡å­—ã«åˆ†å‰²ã™ã‚‹               | words "It is a member"              | ["It","is","a","member"]  |
| group      | éš£æ¥è¦ç´ ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹     | group [2,3,2,2,4,3]                 | [[2],[3],[2,2],[4],[3]]   |
| sort       | ã‚½ãƒ¼ãƒˆã™ã‚‹                   | sort [2,3,2,2,4,3]                  | [2,2,2,3,3,4]             |
| tails      | å…¨ã¦ã®tailãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å–å¾—ã™ã‚‹ | tails [1,2,3]                       | [[1,2,3], [2,3], [3], []] |
| isPrefixOf | prefixã§å§‹ã¾ã‚‹ã‹åˆ¤å®šã™ã‚‹     | isPrefixOf "Mr" "Mr. Tom"           | True                      |
| find       | åˆã‚ã¦æ¡ä»¶ã‚’æº€ãŸã™è¦ç´ ã‚’è¿”ã™ | find (>3) [2,1,4,2,5]               | Just 4                    |
| findIndex  | åˆã‚ã¦æ¡ä»¶ã‚’æº€ãŸã™ä½ç½®ã‚’è¿”ã™ | findIndex (>3) [2,1,4,2,5]          | Just 2                    |
| isInfixOf  | åŒ…å«ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹   | isInfixOf [2,3] [1..5]              | True                      |
| lookup     | keyã‹ã‚‰valueã‚’æ¤œç´¢ã™ã‚‹       | lookup 2 [(1, "taro"), (2, "jiro")] | Just "jiro"               |

### Data.Char

|    é–¢æ•°    |           æ„å‘³           |     è¨˜è¼‰ä¾‹     | çµæœ |
| ---------- | ------------------------ | -------------- | ---- |
| ord        | æ–‡å­—ã‚’å¯¾å¿œæ•°å€¤ã«å¤‰æ›ã™ã‚‹ | ord 'a'        | 97   |
| chr        | æ•°å€¤ã‚’å¯¾å¿œæ–‡å­—ã«å¤‰æ›ã™ã‚‹ | chr 97         | 'a'  |
| digitToInt | æ–‡å­—ã‚’æ•°å­—ã«å¤‰æ›ã™ã‚‹     | digitToInt '6' | 6    |
| isDigit | æ•°å€¤ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ | isDigit '6' | True |

### Data.Map

åå‰ç«¶åˆã™ã‚‹ãŸã‚`import qualified Data.Map as Map`ã§åå‰ä»˜ã‘ã‚‹ã®ãŒã‚ˆã„ã€‚  
`:set -package containers`ãŒå¿…è¦ã ã£ãŸã€‚ã“ã‚Œã¯â“


`fromList`ã§é€£æƒ³ãƒªã‚¹ãƒˆã‹ã‚‰å¤‰æ›ã€‚

```haskell
members :: Map.Map Int String
members = Map.fromList [(1, "tadashi"), (2, "tagayasu"), (3, "seigo")]
```

keyãŒé‡è¤‡ã™ã‚‹å ´åˆã¯`fromListWith`ã‚’ä½¿ã†ã€‚å€¤ã‚’ã©ã†åˆä½“ã•ã›ã‚‹ã‹ã¯æŒ‡å®šãŒå¿…è¦ã€‚

```haskell
members :: Map.Map Int String
members = Map.fromListWith (++) $ map (\(k, v) -> (k, [v])) [(1, "tadashi"), (2, "tagayasu"), (1, "seigo")]
```


|  é–¢æ•°  |          æ„å‘³          |                     è¨˜è¼‰ä¾‹                     |                        çµæœ                        |
| ------ | ---------------------- | ---------------------------------------------- | -------------------------------------------------- |
| lookup | keyã‹ã‚‰valueã‚’æ¤œç´¢ã™ã‚‹ | lookup 2 $ fromList [(1, "taro"), (2, "jiro")] | Just "jiro"                                        |
| insert | è¦ç´ ã‚’æŒ¿å…¥ã™ã‚‹         | insert 3 "saburo"                              | fromList [(1, "taro"), (2, "jiro"), (3, "saburo")] |
| size   | ã‚µã‚¤ã‚ºã®å–å¾—           | size $ fromList [(1, "taro"), (2, "jiro")]     | 2                                                  |

`insert`ãªã©ã§å…ƒã®å€¤ã¯å¤‰ã‚ã‚‰ãªã„ã®ã§æ³¨æ„ã€‚æ–°ã—ã„å¤‰æ•°ã§æŸç¸›ãŒå¿…è¦ã€‚


### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œæˆ

ã“ã‚“ãªæ„Ÿã˜ã§éšå±¤åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```
.
âˆŸsrc
  âˆŸGeometry
    âˆŸCube.hs
    âˆŸCuboid.hs
    âˆŸSphere.hs
```

`Cube.hs`ã¯ã“ã‚“ãªæ„Ÿã˜ã€‚

```haskell
module Geometry.Cube
  ( volume
  , area
  ) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -> Float
volume side = Cuboid.volume side side side

area :: Float -> Float
area side = Cuboid.area side side side
```


ã‚ªãƒªã‚¸ãƒŠãƒ«ã®å‹/å‹ã‚¯ãƒ©ã‚¹
-----------------------

### å‹å®šç¾©

`data`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã†ã€‚

```haskell
data Human = Man Int String Int | Woman Int String
```

* ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å€¤ã‚’è¡¨ç¤ºã•ã›ã‚‹ã«ã¯`deriving (Show)`ãŒå¿…è¦

### å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

ä¸Šè¨˜ã®`Man`ã¨`Woman`ã¯å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚  
å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å‹å¼•æ•°ã‚’å—ã‘å–ã‚‹ã€‚

ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚‚ã§ãã‚‹ã€‚

```haskell
getAge :: Human -> Int
getAge (Man _ _ age) = age
getAge (Woman _ _) = -1
```

å€¤ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ãƒãƒƒãƒã«å¿…ãšå¿…è¦ãªã®ã§ã€å¿˜ã‚Œã¦ã‚¿ãƒ—ãƒ«(`(x y)`)ã«ã—ãªã„ã“ã¨ã€‚

### ãƒ¬ã‚³ãƒ¼ãƒ‰æ§‹æ–‡

è¾æ›¸ã£ã½ã„æ„Ÿã˜ã€‚

```haskell
data Human
  = Man { id   :: Int
        , name :: String
        , age  :: Int }
  | Woman { id   :: Int
          , name :: String }
```

ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œã‚Šæ–¹ã¯2é€šã‚Š

```haskell
Man {id=1, age=32, name="tagayasu"}
Man 1 "tagayasu" 32
```

ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã«ä¸€è‡´ã—ãŸé–¢æ•°ãŒgetterã¨ã—ã¦è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹

```haskell
> name $ Woman 1 "hanako"
"hanako"
```

### å‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

å‹å¼•æ•°ã‚’ã¨ã£ã¦æ–°ã—ã„å‹ã‚’ä½œã‚‹ã€‚

â€» å‹å¼•æ•°ã¯`data Maybe a = Nothing | Just a`ã®`a`
