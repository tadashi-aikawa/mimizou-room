---
description: TypeScript2.8のリリース内容まとめ
---

# [TypeScript] 2.8

{{ page.meta.description }}


## [Conditional Types]

[Conditional Types]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#conditional-types

{{label('had_better')}} {{label('normal')}}

他の型が満たす条件によって、型の切り替えができる。  
`T extends U ? X : Y` と書いて **UにTを割り当て可能ならX、そうでなければY** 型 という意味。

**JavaScriptで書かれたある規則に従って動く関数のInterfaceを明確にするもの** という位置づけだと個人的には思っている。

以下のような国籍と、そのアシスタントを定義した場合..

```typescript
interface Japanese {
  myNo: number;
  name: string;
}

interface American {
  name: string;
}

class JapaneseAssistant {
  private _japaneseAssistantBrand!: never;
  hello(human: Japanese): void {
    console.log(`こんにちは。${human.name}さん`);
  }
}

class AmericanAssistant {
  private _americanAssistantBrand!: never;
  hello(human: American): void {
    console.log(`Hello! ${human.name}!`);
  }
}
```

国籍から最適なアシスタントを判定するConditional Type `Assistant<T>` の実装は以下。

```typescript
type Assistant<T> = T extends Japanese
  ? JapaneseAssistant
  : T extends American
  ? AmericanAssistant
  : unknown;
```

第1引数として指定された国籍から、予想されるアシスタント型を第2引数で推論する`assist`関数の実装は以下。

```typescript
function assist<T extends Japanese | American>(
  human: T,
  assistant: Assistant<T>
) {
  // javascriptで頑張っている実装とかがあるはず..
}
```

tscやIDEで推論およびエラーを出してくれる。

```typescript
const beaton: American = { name: "beaton" };

// 第1引数にAmerican型のObjectを入れることで、第2引数はAmericanAssistantとみなされる
assist(beaton, new AmericanAssistant());

// 第2引数にJapaneseAssistantを入れるとエラーになる
assist(beaton, new JapaneseAssistant());
```

## [Distributive conditional types]

[Distributive conditional types]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types

{{label('had_better')}} {{label('hard')}}

Conditional typesにUnion typesが指定された場合、適切に分散する。  
具体的には、Union typesで指定されたそれぞれの型について条件判定を行う。

```typescript
// T1はstringとbooleanそれぞれに対して↑の判定が行われる
// stringは"STR"、booleanは"BOOL"のため "STR" | "BOOL" 型と判定される
type T1 = TypeName<string | boolean>
```

`TypeName<T>`の定義は以下の通り。

```typescript
type TypeName<T> = T extends string
  ? "STR"
  : T extends number
  ? "NUM"
  : T extends boolean
  ? "BOOL"
  : T extends undefined
  ? "NONE"
  : T extends Function
  ? "FUNC"
  : "OBJ";
```

Conditional typesは再帰を許容しない。

!!! question "確かどこかのバージョンで許容するようになったはず。。"

いくつかサンプルコードを紹介する。

### アサイン可能な型のみフィルターするFilter型

```typescript
type Filter<T, U> = T extends U ? T : never;
```

TがUnion Typesのとき、`Filter<T, U>`はUにアサイン可能な型のみをTから抽出した型である。  
たとえば、以下の`T1`は`boolean`となる。

```typescript
type T1 = Filter<number | string | boolean, Boolean | object>
// T1 = boolean
```

Tに指定されたUnion typesの型(`number | string | boolean`)はそれぞれについてConditional typesとして判定されるため

| T       | U                 | T extends U ? | 結果    |
| ------- | ----------------- | ------------- | ------- |
| number  | Boolean ￨ object | false         | never   |
| string  | Boolean ￨ object | false         | never   |
| boolean | Boolean ￨ object | true          | boolean |

よって `boolean` になる。

### アサイン不可能な型のみ抽出するDiff型

`Filter`型の逆。

```typescript
type Diff<T, U> = T extends U ? never : T;
```

TがUnion Typesのとき、`Diff<T, U>`はUにアサイン不可能な型のみをTから抽出した型である。  
たとえば、以下の`T1`は`number | string`となる。

```typescript
type T2 = Diff<number | string | boolean, Boolean | object>
// T2 = number | string
```

Tに指定されたUnion typesの型(`number | string | boolean`)はそれぞれについてConditional typesとして判定されるため

| T       | U                 | T extends U ? | 結果   |
| ------- | ----------------- | ------------- | ------ |
| number  | Boolean ￨ object | false         | number |
| string  | Boolean ￨ object | false         | string |
| boolean | Boolean ￨ object | true          | never  |

よって `number | string` になる。

### null/undefinedを除外した型NonNullable

先ほど作成した`Diff`型を使う。

```typescript
type NonNullable<T> = Diff<T, null | undefined>;
```

### 関数のプロパティ名をUnion typesとして成すFunctionPropertyName型

```typescript
type FunctionPropertyName<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
```

具体例からイメージを沸かせるため`Human`インタフェースを定義し、それを交えて説明する。

```typescript
interface Human {
  id: number;
  name: string;
  hello(): void;
  goodBye(): boolean;
}
```

[keyof and Lookup Types]である`[keyof T]`を外して、まずは[Mapped Types]の解析をする。

```typescript
{
  [K in keyof T]: T[K] extends Function ? K : never;
}
```

`T`に`Human`を割り当て、`K`を解くと以下の様になる。

```typescript
{
  id: Human["id"] extends Function ? "id" : never;
  name: Human["name"] extends Function ? "name" : never;
  hello: Human["hello"] extends Function ? "hello" : never;
  goodBye: Human["goodBye"] extends Function ? "goodBye" : never;
}
```

よって

```typescript
{
  id: never;
  name: never;
  hello:  "hello";
  goodBye:  "goodBye";
}
```

これに`[key of T]`をつけると..

```typescript
{
  id: never;
  name: never;
  hello:  "hello";
  goodBye:  "goodBye";
}[keyof Human]
```

よって `"hello" | "goodBye"` になる。


[keyof and Lookup Types]: ../2.1/#keyof-and-lookup-types
[Mapped Types]: ../2.1/#mapped-types


## [Type inference in conditional types]

[Type inference in conditional types]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types

{{label('had_better')}} {{label('hard')}}

Conditional typesでマッチングしたパターンから、一部の型を`infer`でキャプチャできる。  
具体例を見た方が分かりやすい。

### Promiseで包まれた型を取り出すUnwrapPromise

```typescript
type UnwrapPromise<T> = T extends Promise<infer U> ? U : any;
```

これは以下のように解釈できる。

* `UnwrapPromise<T>`は
  * `T` が `Promise<U>` に割り当て可能なら(このケースではPromiseなら)、`U`型
  * そうでなければ`any`型
* `infer U`が`Promise<U>`というパターンにマッチする`U`をキャプチャする

具体例。

```typescript
type R = UnwrapPromise<Promise<number>>
// => number
type S = UnwrapPromise<number>
// => any (Promiseで包まれていないのでパターンにマッチしない)
```

### 関数のReturnする型を取得するMyReturnType

```typescript
type MyReturnType<T> = T extends (...arg: any[]) => infer R ? R : any;
```

これは以下のように解釈できる。

* `MyReturnType<T>`は
  * `T` が `(...arg: any[]) => R` に割り当て可能なら(このケースでは関数なら)、`R`型
  * そうでなければ`any`型
* `infer R`が`(...arg: any[]) => R`というパターンにマッチする`R`をキャプチャする

具体例。

```
type R = MyRetrunType<Math.atan2>
// => number
type S = MyRetrunType<number>
// => any (関数ではないのでパターンにマッチしない)
```

### co-variantの位置関係にある同一な複数型における推論

`{ a: infer U, b: infer U }`のような共変位置にある場合、推論結果はUnion typeになる。

```typescript
interface A {
  p1: "x" | "y";
  p2: "y" | "z";
}

type Property<T> = T extends { p1: infer U, p2: infer U } ? U : never;
type N = Property<A>;
// => "y" | "z" | "x"
```

### contra-variantの位置関係にある同一な複数型における推論

`{ a: (x: infer U) => void, b: (x: infer U) => void }`のような反変位置にある場合、推論結果はIntersection typeになる。

```typescript
interface A {
  p1: (arg: "x" | "y") => void;
  p2: (arg: "y" | "z") => void;
}

type Property<T> = T extends { p1: (arg: infer U) => void, p2: (arg: infer U) => void } ? U : never;
type N = Property<A>;
// => "y"
```
